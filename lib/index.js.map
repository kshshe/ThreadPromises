{"mappings":";;;;;;;;;;AEAe,kDAAyB,QAAgB,EAAU;IAChE,OAAO,CAAC;;gBAEM,EAAE,SAAS;;;;;;;;;;;;;;;;;;;;;;EAsBzB,CAAC;AACH;;AD1BA;AAsBe;IACL,uBAA2D,IAAM,CAAC,EAAE;IACpE,qBAAuD,IAAM,CAAC,EAAE;IAMxE,YAAY,QAAkE,EAAE,GAAG,UAAuB,CAAE;QAC1G,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,GAAG;QAElB,IAAI,OAAO,WAAW,eAAe,OAAO,MAAM,EAChD,WAAW,IAAM;YACf,IAAI,CAAC,YAAY;YACjB,IAAI,CAAC,WAAW;QAClB;aACK;YACL,SAAS,iBAAiB,OAAO,EAAE,MAAM,EAAE;gBACzC,SAAS,SAAS,WAAW;YAC/B;YACA,OAAO,IAAI,QAAqB;QAClC,CAAC;IACH;IAEQ,eAAe;QACrB,IAAI,OAAO,IAAI,KAAK;YAAC,IAAI,CAAC,oBAAoB;SAAG;QACjD,MAAM,IAAI,OAAO,GAAG,IAAI,OAAO,SAAS;QACxC,IAAI,UAAU,OAAO,GAAG,CAAC,eAAe,CAAC;QACzC,IAAI,CAAC,MAAM,GAAG,IAAI,OAAO;QACzB,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI;IACtD;IAEQ,cAAc,CAAyD,EAAE;QAC/E,MAAM,QAAE,KAAI,QAAE,KAAI,EAAE,GAAG,EAAE,IAAI;QAC7B,OAAQ;YACN,KAAK;gBACH,IAAI,CAAC,oBAAoB,CAAC;gBAC1B,KAAM;YACR,KAAK;gBACH,IAAI,CAAC,kBAAkB,CAAC;gBACxB,KAAM;YACR;gBACE,KAAM;QACV;IACF;IAEQ,cAAc;QACpB,MAAM,UAAsC;YAC1C,YAAY,IAAI,CAAC,UAAU;QAC7B;QACA,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;IAC1B;IAEQ,uBAAuB;QAC7B,MAAM,WAAW,IAAI,CAAC,QAAQ,CAAC,QAAQ;QACvC,OAAO,CAAA,GAAA,wCAAc,EAAE;IACzB;IAEA,KAAK,QAA4C,EAAE;QACjD,IAAI,CAAC,oBAAoB,GAAG;QAC5B,OAAO,IAAI;IACb;IAEA,MAAM,QAA0C,EAAE;QAChD,IAAI,CAAC,kBAAkB,GAAG;QAC1B,OAAO,IAAI;IACb;AACF;;AD1FA;IAEA,2CAAe,CAAA,GAAA,wCAAO","sources":["index.ts","src/TPromise.ts","src/getFunctionBody.ts"],"sourcesContent":["import TPromise from \"./src/TPromise\"\n\nexport default TPromise","import getFunctionBody from './getFunctionBody';\n\ntype TExecutorFunction<TParameters extends Array<unknown>, TReturnType, TRejectType> = \n  (resolve: (value: TReturnType) => void, \n  reject: (reason: TRejectType) => void, \n  ...parameters: TParameters) => void;\n\ntype TStartMessage<TParameters extends Array<unknown>> = {\n  parameters: TParameters;\n};\n\ntype TResultMessage<TReturnType, TRejectType> = {\n  type: \"onFullfilledCallback\",\n  data: TReturnType,\n} | {\n  type: \"onRejectedCallback\",\n  data: TRejectType,\n}\n\ntype TOnFullfilledCallback<TReturnType> = (data: TReturnType) => void;\ntype TOnRejectedCallback<TRejectType> = (data: TRejectType) => void;\n\nexport default class TPromise<TParameters extends Array<unknown>, TReturnType, TRejectType> {\n  private onFullfilledCallback: TOnFullfilledCallback<TReturnType> = () => {};\n  private onRejectedCallback: TOnRejectedCallback<TRejectType> = () => {};\n\n  private executor: TExecutorFunction<TParameters, TReturnType, TRejectType>;\n  private parameters: TParameters;\n  private worker: Worker;\n  \n  constructor(executor: TExecutorFunction<TParameters, TReturnType, TRejectType>, ...parameters: TParameters) {\n    this.executor = executor;\n    this.parameters = parameters;\n\n    if (typeof window !== \"undefined\" && window.Worker) {\n      setTimeout(() => {\n        this.createWorker();\n        this.startWorker();\n      });\n    } else {\n      function fallbackExecutor(resolve, reject) {\n        executor(resolve, reject, ...parameters);\n      }\n      return new Promise<TReturnType>(fallbackExecutor) as unknown as TPromise<TParameters, TReturnType, TRejectType>;\n    }\n  }\n\n  private createWorker() {\n    var blob = new Blob([this.createWorkerFunction()]);\n    const U = window.URL || window.webkitURL;\n    var blobURL = window.URL.createObjectURL(blob);\n    this.worker = new Worker(blobURL);\n    this.worker.onmessage = this.handleMessage.bind(this);\n  }\n\n  private handleMessage(e: MessageEvent<TResultMessage<TReturnType, TRejectType>>) {\n    const { data, type } = e.data;\n    switch (type) {\n      case \"onFullfilledCallback\":\n        this.onFullfilledCallback(data);\n        break;\n      case \"onRejectedCallback\":\n        this.onRejectedCallback(data);\n        break;\n      default:\n        break;\n    }\n  }\n\n  private startWorker() {\n    const message: TStartMessage<TParameters> = {\n      parameters: this.parameters,\n    };\n    this.worker.postMessage(message);\n  }\n\n  private createWorkerFunction() {\n    const executor = this.executor.toString();\n    return getFunctionBody(executor);\n  }\n\n  then(callback: TOnFullfilledCallback<TReturnType>) {\n    this.onFullfilledCallback = callback;\n    return this;\n  }\n\n  catch(callback: TOnRejectedCallback<TRejectType>) {\n    this.onRejectedCallback = callback;\n    return this;\n  }\n};\n","export default function getFunctionBody(executor: string): string {\n  return `\n    function getExecutor() {\n        return (${executor});\n    }\n    function onFullfilledCallback(data) {\n      self.postMessage({\n        type: \"onFullfilledCallback\",\n        data,\n      });\n      self.close();\n    }\n    function onRejectedCallback(data) {\n      self.postMessage({\n        type: \"onRejectedCallback\",\n        data,\n      });\n      self.close();\n    }\n    const executor = getExecutor();\n    self.onmessage = function ({\n      data: { parameters },\n    }) {\n      executor(onFullfilledCallback, onRejectedCallback, ...(parameters || []));\n    };\n  `\n}\n"],"names":[],"version":3,"file":"index.js.map"}