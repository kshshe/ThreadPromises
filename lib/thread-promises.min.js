(() => {
  function e(e) {
    return `\n    function getExecutor() {\n        return (${e});\n    }\n    function onFullfilledCallback(data) {\n      self.postMessage({\n        type: "onFullfilledCallback",\n        data,\n      });\n      self.close();\n    }\n    function onRejectedCallback(data) {\n      self.postMessage({\n        type: "onRejectedCallback",\n        data,\n      });\n      self.close();\n    }\n    const executor = getExecutor();\n    self.onmessage = function ({\n      data: { parameters },\n    }) {\n      executor(onFullfilledCallback, onRejectedCallback, ...(parameters || []));\n    };\n  `;
  }
  window.TPromise = class {
    onFullfilledCallback = () => {};
    onRejectedCallback = () => {};
    constructor(e, ...t) {
      if (
        ((this.executor = e),
        (this.parameters = t),
        "undefined" == typeof window || !window.Worker)
      ) {
        function n(n, a) {
          e(n, a, ...t);
        }
        return new Promise(n);
      }
      setTimeout(() => {
        this.createWorker(), this.startWorker();
      });
    }
    createWorker() {
      var e = new Blob([this.createWorkerFunction()]);
      window.URL || window.webkitURL;
      var t = window.URL.createObjectURL(e);
      (this.worker = new Worker(t)),
        (this.worker.onmessage = this.handleMessage.bind(this));
    }
    handleMessage(e) {
      const { data: t, type: n } = e.data;
      switch (n) {
        case "onFullfilledCallback":
          this.onFullfilledCallback(t);
          break;
        case "onRejectedCallback":
          this.onRejectedCallback(t);
      }
    }
    startWorker() {
      const e = { parameters: this.parameters };
      this.worker.postMessage(e);
    }
    createWorkerFunction() {
      return e(this.executor.toString());
    }
    then(e) {
      return (this.onFullfilledCallback = e), this;
    }
    catch(e) {
      return (this.onRejectedCallback = e), this;
    }
  };
})();
//# sourceMappingURL=thread-promises.min.js.map
